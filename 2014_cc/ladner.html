<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Teorema de Ladner</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Teorema de Ladner</h1>
</div>
<h1 id="enunciado">Enunciado</h1>
<p>Asumamos <strong>P</strong>≠<strong>NP</strong>. Entonces existe un lenguaje <span class="math"><em>L</em> ∈ </span><strong>NP</strong><span class="math"> \ </span><strong>P</strong> que no es <strong>NP</strong> completo.</p>
<h1 id="preliminarios">Preliminarios</h1>
<p>Dado <span class="math"><em>i</em> ∈ ℕ</span>, llamamos <span class="math"><em>M</em><sub><em>i</em></sub></span> la máquina de Turing representada por la representación binaria de la string <span class="math">⌊<em>i</em>⌋</span>. Si esta string no representa ninguna MT, mapeamos <span class="math"><em>i</em></span> a una máquina que no hace nada.</p>
<p>Una máquina está representada por una cantidad infinita de strings.</p>
<h1 id="demostración">Demostración</h1>
<p>Para toda función <span class="math"><em>H</em> : ℕ ↦ ℕ</span>, definimos <br /><span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub> = {<em>φ</em>01<sup><em>n</em><sup><em>H</em>(<em>n</em>)</sup></sup> ∣ <em>φ</em> ∈ <em>S</em><em>A</em><em>T</em>, <em>n</em> = |<em>φ</em>|}</span><br /></p>
<p>Ahora, definimos <span class="math"><em>H</em> : ℕ ↦ ℕ</span> de la manera siguiente:</p>
<p>H(0) = H(1) = 0</p>
<p>H(n) es el <span class="math"><em>i</em> &lt; <em>l</em><em>o</em><em>g</em><em>l</em><em>o</em><em>g</em><em>n</em></span> más chiquito tal que para todo input <span class="math"><em>x</em></span> de tamaño <span class="math"> ≤ <em>l</em><em>o</em><em>g</em><em>n</em></span>, <span class="math"><em>M</em><sub><em>i</em></sub></span> sale <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub>(<em>x</em>)</span> en <span class="math"><em>i</em>|<em>x</em>|<sup><em>i</em></sup></span> pasos. Si no hay tal <span class="math"><em>i</em></span>, ponemos <span class="math"><em>H</em>(<em>n</em>) = <em>l</em><em>o</em><em>g</em><em>l</em><em>o</em><em>g</em><em>n</em></span>.</p>
<ul>
<li><p><strong>Claim</strong> <span class="math"><em>H</em></span> está bien definida: <span class="math"><em>H</em>(<em>n</em>)</span> sirve para definir las strings de <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span> de longitud superior a <span class="math"><em>n</em></span> (por definición de <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span>), mientras que la definición de <span class="math"><em>H</em></span> depende de chequear strings de longitud <span class="math"><em>l</em><em>o</em><em>g</em><em>n</em></span> cómo máximo.</p></li>
<li><p><strong>Claim</strong> se puede computar <span class="math"><em>H</em>(<em>n</em>)</span> en <span class="math"><em>O</em>(<em>n</em><sup>3</sup>)</span> pasos: ejercicio.</p></li>
<li><strong>Claim</strong>: <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub> ∈ </span> <strong>P</strong> ssi <span class="math">∀<em>n</em>∃<em>C</em></span>. <span class="math"><em>H</em>(<em>n</em>) ≤ <em>C</em></span>
<ul>
<li>(←): si <span class="math"><em>H</em>(<em>n</em>) ≤ <em>C</em></span>, <span class="math"><em>H</em>(<em>n</em>)</span> sólo puede tomar un número finito de valores <br />→ existe <span class="math"><em>i</em></span> tal que <span class="math"><em>H</em>(<em>n</em>) = <em>i</em></span> para un número infinito de <span class="math"><em>n</em></span> <br />→ <span class="math"><em>M</em><sub><em>i</em></sub></span> decide <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span> en tiempo <span class="math"><em>i</em>.<em>n</em><sup><em>i</em></sup></span> (si no, <span class="math">∃<em>x</em></span> tq <span class="math"><em>M</em><sub><em>i</em></sub>(<em>x</em>)</span> no tiene ouput correcto en tiempo <span class="math"><em>i</em>.<em>n</em><sup><em>i</em></sup></span>, entonces, <span class="math">∀<em>n</em> &gt; 2<sup>|<em>x</em>|</sup></span>, <span class="math"><em>H</em>(<em>n</em>) ≠ <em>i</em></span>) <br /><strong>Observación</strong> esto es cierto también si sólo asumimos que existe una constante <span class="math"><em>C</em></span> tal que <span class="math"><em>H</em>(<em>n</em>) ≤ <em>C</em></span> para una cantidad infinita de <span class="math"><em>n</em></span>, entonces tenemos: si <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub> ∉ </span> <strong>P</strong> entonces <span class="math">lim<em>H</em>(<em>n</em>) =  + ∞</span></li>
<li>(→): supongamos M decide <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span> en <span class="math"><em>c</em>.<em>n</em><sup><em>c</em></sup></span> pasos. Cómo existe una cantidad infinita de strings que representa <span class="math"><em>M</em></span>, existe un <span class="math"><em>i</em> &gt; <em>c</em></span> tal que <span class="math"><em>M</em> = <em>M</em><sub><em>i</em></sub></span> (entonces <span class="math"><em>M</em></span> corre en <span class="math"><em>i</em>.<em>n</em><sup><em>i</em></sup></span> pasos). <br />Entonces para <span class="math"><em>n</em> ≥ 2<sup>2<sup><em>i</em></sup></sup></span> tenemos <span class="math"><em>H</em>(<em>n</em>) ≤ <em>i</em></span>.</li>
</ul></li>
</ul>
<p>Con el último Claim, mostramos que si <strong>P</strong>≠<strong>NP</strong>, <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span> no está en <strong>P</strong> ni es <strong>NP</strong> completo.</p>
<p>Supongamos <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub> ∈ </span> <strong>P</strong>. Entonces <span class="math">∀<em>n</em>∃<em>C</em>.<em>H</em>(<em>n</em>) ≤ <em>C</em></span>. Podemos construir una reducción polinomial <span class="math"><em>f</em></span> de SAT a <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span> de tal manera: sea <span class="math"><em>x</em></span>, computamos <span class="math"><em>H</em>(|<em>x</em>|)</span> (en tiempo polinomial), generamos la string <span class="math">01<sup>|<em>x</em>|<sup><em>H</em>(|<em>x</em>|)</sup></sup></span> (de longitud <span class="math">1 + |<em>x</em>|<sup><em>C</em></sup></span> polinomial). Entonces SAT<span class="math"> ∈ </span><strong>P</strong> y <strong>P</strong> = <strong>NP</strong> <span class="math"> ⊗ </span>.</p>
<p>Ahora supongamos <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span> es <strong>NP</strong> completo.</p>
<p>Entonces existe una reducción <span class="math"><em>f</em></span> de SAT a <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span> corriendo en tiempo <span class="math"><em>O</em>(<em>n</em><sup><em>d</em></sup>)</span> con <span class="math"><em>d</em></span> constante. Entonces <span class="math">|<em>f</em>(<em>x</em>)| ≤ |<em>x</em>|<sup><em>d</em></sup></span> para cualquier <span class="math"><em>x</em></span></p>
<p>Dado que <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span> no está en <strong>P</strong>, tenemos <span class="math">lim<em>H</em>(<em>n</em>) =  + ∞</span> <span class="math"><em>f</em></span> corre en tiempo polinomial entonces existe un <span class="math"><em>n</em><sub>0</sub></span> tal que <span class="math"><em>f</em></span> mapea instancias de SAT de tamaño <span class="math"><em>n</em> &gt; <em>n</em><sub>0</sub></span> a instancias de <span class="math"><em>S</em><em>A</em><em>T</em><sub><em>H</em></sub></span> de tamaño <span class="math"> &lt; <em>n</em><sup><em>H</em>(<em>n</em>)</sup></span>. <span class="math"><em>n</em><sup><em>H</em>(<em>n</em>)</sup></span> no es acotado por ningun polinomio.</p>
<p>Describimos un algoritmo para decidir SAT usando <span class="math"><em>f</em></span>: Para input <span class="math">|<em>φ</em>| &lt; <em>n</em><sub>0</sub></span>, codificamos en duro las respuestas. Para input <span class="math">|<em>φ</em>| ≥ <em>n</em><sub>0</sub></span>:</p>
<ul>
<li>construir <span class="math"><em>f</em>(<em>φ</em>)</span></li>
<li>si <span class="math"><em>f</em>(<em>φ</em>)</span> no es de la forma <span class="math"><em>ψ</em>01<sup>|<em>ψ</em>|<sup><em>H</em>(<em>ψ</em>)</sup></sup></span>, return UNSAT (chequeo en tiempo poli.: medir <span class="math">|<em>ψ</em>|</span>, computar <span class="math"><em>H</em>(|<em>ψ</em>|)</span> y <span class="math">|<em>ψ</em>|<sup><em>H</em>(|<em>ψ</em>|)</sup></span>), sino seguir</li>
<li><p>correr el algoritmo sobre <span class="math"><em>ψ</em></span></p></li>
<li><p><strong>Claim</strong> Para cada llamada recursiva del algoritmo, el tamaño del input decrece.<br /> Demo. por el absurdo: asumamos <span class="math">|<em>x</em>| ≥ <em>n</em><sub>0</sub></span>, <span class="math"><em>f</em>(<em>x</em>) = <em>ψ</em><sub><em>x</em></sub>01<sup>|<em>ψ</em><sub><em>x</em></sub>|<sup><em>H</em>(<em>ψ</em><sub><em>x</em></sub>)</sup></sup></span> y <span class="math">|<em>ψ</em><sub><em>x</em></sub>| ≥ |<em>x</em>|</span> (el input no decrece). Tendríamos entonces <span class="math">|<em>ψ</em><sub><em>x</em></sub>| ≥ <em>n</em><sub>0</sub></span> y <br /> <span class="math">|<em>x</em>| + 1 + |<em>x</em>|<sup><em>d</em></sup> ≤ |<em>ψ</em><sub><em>x</em></sub>| + 1 + |<em>ψ</em><sub><em>x</em></sub>|<sup><em>H</em>(|<em>ψ</em><sub><em>x</em></sub>|)</sup> ≤ |<em>x</em>|<sup><em>d</em></sup></span>, contradicción.</p></li>
</ul>
<p>Entonces esto es un algoritmo polinomial para decidir SAT, entonces <strong>P</strong>=<strong>NP</strong>, lo que contradice nuestra asumpción inicial.</p>
</body>
</html>
