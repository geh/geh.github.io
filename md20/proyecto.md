% MD3-computabilidad: coloquio

# Presentación general

Este proyecto se puede hacer solo o en grupo de 2.

Las instrucciones de entrega y de evaluación del proyecto
están al final de este documento.

# Maquinas de Turing Binarias Cíclicas (MTBC)

Una Máquina de Turing binaria cíclica (MTBC) es una simplificación de la Máquina de Turing
que vimos al principio del semestre.
La diferencia es que su estado interno cambia cíclicamente: pasa de `a`
al `b`, luego `c`, y así. Cuando llega a su último estado, vuelve al estado `a` y sigue.

Entonces la tabla de transiciones de una MTBC es más simple que en una MT común.

Para cada par *(estado activo,símbolo leido)*, la tabla indica qué acción efectuar.
Las acciones son 5 posibles:

* finalizar la ejecución
* escribir 0 y mover el cabezal a la izquierda
* escribir 0 y mover el cabezal a la derecha
* escribir 1 y mover el cabezal a la izquierda
* escribir 1 y mover el cabezal a la derecha

Por ejemplo, esto sería la tabla de transición de alguna MTBC:

~~~
  | 0| 1|
a |1>|1<|
b |1<|1>|
c | F|1>|
~~~

Tal tabla se puede representar por una cadena de caracteres.
Usamos la codificación siguiente: 

 instrucción                                           representación ascii
------------------------------------------------      ----------------------
finalizar la ejecución                                f
escribir 0 y mover el cabezal a la izquierda          o
escribir 0 y mover el cabezal a la derecha            O
escribir 1 y mover el cabezal a la izquierda          i
escribir 1 y mover el cabezal a la derecha            I

La tabla anterior tiene como representacion en cadena de caracteres: `IiiIfI`.

Y la siguiente:

~~~
  | 0| 1|
a |0>| F|
b |0<|1>|
c |1>|1<|
~~~

Tiene como representación: `OfoIIi`

# 1. Objetivo del proyecto

Se trata de escribir un programa capaz de tomar la tabla de transición de una MTBC como
parámetro en línea de comando, ejecutarla cierta hasta llegar a que se detenga o
hasta que se hayan ejecutado cierta cantidad de pasos.

Debés implementar la simulación de MTBC a partir de una situación inicial "cinta a cero".
En cada paso se debe imprimir la cinta, y la instrucción que se está por ejecutar (mostrando
su código en la representación en cadena de caracteres).

El programa tiene que decir si la simulación se terminó sin que la máquina haya llegado
a una instruccion "fin". En el caso contrario, el programa indica cuántos pasos se ejecutó
la simulación.

La simulación siempre empieza con las condiciones siguientes:

* la cinta de trabajo está completamente inicializada a cero
* el estado interno de la máquina es `a` (el primero)

Observá que podés trabajar con un arreglo de tamaño fijo, dado que si conocés el
limite `t` de cantidad de pasos para la ejecución de la máquina, no necesitás más
que un arreglo de tamaño `2t+1`. Podés suponer que, por defecto, `t` vale 50.

# 2. Salidas a imitar

Unos ejemplos de como se puede ejecutar tu programa y qué salida tiene que tener:

~~~
$ ./a.out IiiofI
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000 instruccion f
fin de ejecucion en 6 pasos
~~~

~~~
$ ./a.out IiioIf
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000 instruccion f
fin de ejecucion en 3 pasos
~~~

~~~
$ ./a.out IiioIi
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000000000111000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000000000101000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000000001101000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000000000001001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000000001001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000000011001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000000000010001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000000010001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000000110001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000000000100001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000000100001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000001100001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000000001000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000001000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000011000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000000010000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000010000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000000110000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000000100000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000000100000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000001100000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000001000000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000001000000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000011000000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000010000000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000010000000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000000110000000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000000100000000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000000100000000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000001100000000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000001000000000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000001000000000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000011000000000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000010000000000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000010000000000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000000110000000000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000000100000000000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000000100000000000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000001100000000000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000001000000000000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000001000000000000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000011000000000000001000000000000000000000000000000000000000000000000 instruccion o
0000000000000000000000000000000000010000000000000001000000000000000000000000000000000000000000000000 instruccion i
0000000000000000000000000000000000010000000000000001000000000000000000000000000000000000000000000000 instruccion I
0000000000000000000000000000000000110000000000000001000000000000000000000000000000000000000000000000 instruccion o
fin de ejecucion por limite de tiempo (50 pasos)
~~~

# Ejemplos para verificar la implementación

Podés usar los ejemplos siguientes para controlar que tu programa no tiene errores.

~~~
Iiif         6 pasos
Iiof         supera el limite de 50 pasos
IiioIf       3 pasos
IiiofI       6 pasos
IiioooIf     8 pasos
IiiooiIf    12 pasos
~~~

# 3. Modo búsqueda

Implementá un modo "búsqueda aleatoria" de máquinas de `n` estados
que tenga un tiempo de ejecución de más de `t` pasos. Por ejemplo
la ejecución siguiente genera aleatoriamente máquinas de 5 estados,
hasta encontrar alguna que se ejecuta en más de 10 pasos, terminando:

~~~bash
$ ./a.out -n 5 -t 10
~~~

La salida de este modo es libre.

Es posible que esa búsqueda no devuelva nunca una respuesta, porque
no existe tal máquina.

Una pregunta abierta interesante es: dado un entero `n`,
¿cuál es la cantidad máxima de pasos que puede hacer una MTBC
de `n` estados antes de detenerse?

Pensá en una estrategia para acercarte de la respuesta para un `n` dado. Todo vale.
Con la entrega de tu programa, entregá candidatos de respuestas para la
categorias 4, 5, 6 y 7 estados.

# Criterios de evaluación y de regularidad

Mandar el código a <guillaume.hoffmann@conicet.gov.ar>, junto con una descripción del proyecto
en unos párrafos.

Indicar los nombres de los integrantes del grupo en el codigo fuente, y llamar el archivo
con los apellidos de los integrantes.

La elección del lenguaje de programación es libre.
Se debe entregar el código fuente con instrucciones para compilarlo.
Si el lenguaje es demasiado esotérico, provean ejecutable para Linux 64 bits.

**Esta entrega tiene que hacerse antes del martes 3/12 a las 18hs**. Si no se hace
esta entrega o si esta no cumple con lo enunciado anteriormente, directamente se reprueba
el coloquio.

Luego, **se presentará el coloquio el día jueves 5/12 a las 18hs**.
Se evaluará si tu proyecto cumple con los puntos 1, 2 y 3.

Se tomará en cuenta (en el orden siguiente de prioridad):

* que el código sea autoría de quienes lo entreguen
* que sea mantenible, es decir, si se cambian los requisitos del enunciado,
  sea fácil de modificar
* que sea el más corto posible (en cantidad de sentencias y de variables usadas)
* que esté bien presentado (con indentación, elegir bien los nombres de variables)

